--------------------------- MODULE euclid_pluscal ---------------------------

EXTENDS Integers, gcd

CONSTANTS M, N
ASSUME M \in Nat \{0}
ASSUME N \in Nat \{0}




(****************************************************

--algorithm Euclid {
    variables x = M;
              y = N;
              { while ( x # y ) { if (x < y) { y := y - x }
                                  else       { x := x - y }
              } 
              }
}

*****************************************************)  
(* Beginning pluscal was from top to this point. Declaring
   VARIABLES x, y at the top level gives a warning about 
   repreated declarations; the ones generated by the translation
   clash with the top declaration *)

\* BEGIN TRANSLATION

VARIABLES x, y, pc

vars == << x, y, pc >>
(* Not necessarily extraneous, since " a triple od x, y, and pc " has 
   in many cases different properties than just VARIABLES x, y, pc. Can
   be used as a state mapping *)

Init == (* Global variables *)
        /\ x = M
        /\ y = N
        /\ pc = "Lbl_1"

                 
       
(***************************************************************************
  Traditional If/Then/Else style statement
 ***************************************************************************)        
if_then_else == IF (x < y) THEN /\ (y' = y - x) 
                                /\ (x' = x) 
                                /\ (pc' = "Lbl_1") 
                           ELSE IF (x > y) THEN /\ (x' = x - y) 
                                                /\ (y' = y) 
                                                /\ (pc' = "Lbl_1")
                                           ELSE /\ (x = y)
                                                /\ (pc' = "Done")
                                                /\ UNCHANGED << x , y >>
                                                
\* Lbl_1 = pc = "Lbl_1" /\ if_then_else

(***************************************************************************
  Using Purely conunction and disjunction
 ***************************************************************************)
                     
if_then_else_conj ==  \/ 
                         /\ (x < y) 
                         /\ (y' = y - x)
                         /\ (x' = x)
                         /\ (pc' = "Lbl_1")
                      \/ 
                         /\ (x > y)
                         /\ (x' = x - y)
                         /\ (y' = y)
                         /\ (pc' = "Lbl_1")
                      \/ 
                         /\ (x = y)
                         /\ (pc' = "Done")
                         /\ UNCHANGED << x , y >>

\* Lbl_1 == pc = "Lbl_1" /\ if_then_else_conj

(***************************************************************************
  Using implication. Stil not sure why this wants Conjunction or really 
  how this works internally.
 ***************************************************************************)                   
if_then_else_impl == /\ (x < y) => /\ y' = y - x
                                   /\ x' = x
                                   /\ pc' = "Lbl_1"
                     /\ (x > y) => /\ x' = x - y
                                   /\ y' = y
                                   /\ pc' = "Lbl_1"
                     /\ (x = y) => /\ pc' = "Done"
                                   /\ UNCHANGED << x, y >>
   
\* Lbl_1 == (pc = "Lbl_1") /\ if_then_else_impl


(***************************************************************************
  The one it came with. 
 ***************************************************************************)           

Lbl_1 == /\ pc = "Lbl_1"
         /\ IF x # y
               THEN /\ IF x < y
                          THEN /\ y' = y - x
                               /\ x' = x
                          ELSE /\ x' = x - y
                               /\ y' = y
                    /\ pc' = "Lbl_1"
               ELSE /\ pc' = "Done"
                    /\ UNCHANGED << x, y >>
                    
                
Next == Lbl_1
           \/ (* Disjunct to prevent deadlock on termination *)
              (pc = "Done" /\ UNCHANGED vars)


Spec == Init /\ [][Next]_vars

Termination == <>(pc = "Done")

PartialCorrectness == (pc = "Done") => (x = y) /\ (x = GCD(M, N))



\* END TRANSLATION



=============================================================================
\* Modification History
\* Last modified Sun Nov 11 10:40:28 CST 2018 by pnkm
\* Created Tue Nov 06 03:38:07 CST 2018 by pnkm
